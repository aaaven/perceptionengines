# Perception Engines

Not complete yet! Should be coherent by 13 Dec 2019.

## Getting Started

### Rendering System

Images are generated by "renderers". These generally go into into the
"renderer" subdirectory of the classpath and are loaded dynamically.
They also generally have a simple numbered version scheme since it
is handy to keep old versions around once you have output files
that depend on them.

To see a renderer in action, we can run the "render_images" script.

```bash
python render_images.py
```

This will run the default "lines1" renderer which draws colored lines
on the canvas. With no arguments, the lines will be randomly generated
and then saved to a templated file. Take note of the printed output file
and open it up to see what was created.

A renderer is really just a python file that contains a render function:
```python
# input: array of real vectors, length 8, each component normalized 0-1
def render(a, size):
```

The numpy array a is a variable list of length 8 vectors and size is
the dimensions of the output image in pixels. The renderer should
generate and return an image. Its very important for the output images
to be identical when size varies.


The best way to get started is to make a copy of lines1 and try your own stuff.
Here are a bunch of different ways to run `render_images` with more explicit
arguments.


Provide the renderer, random seed, size, and size manually
```bash
python render_images.py \
  --renderer lines1 \
  --random-seed 3 \
  --size 1200
  ```

Now that we are supplying a fixed random-seed, we can test if this matches when scaled
```bash
python render_images.py \
  --renderer lines1 \
  --random-seed 3 \
  --size 600
```

And should change when the random seed is changed
```bash
python render_images.py \
  --renderer lines1 \
  --random-seed 4 \
  --size 600
```

To draw fewer lines, change the length of the input array
```bash
python render_images.py \
  --renderer lines1 \
  --random-seed 4 \
  --length 10 \
  --size 600
```

The output file can be fixed and named with different file formats possible:
```bash
python render_images.py \
  --renderer lines1 \
  --random-seed 4 \
  --length 10 \
  --size 600 \
  --outfile outputs/test_length10.jpg
```

Templated output file names using variables are handy. SEQ will auto-increment when re-run. (run this one a few times to get different versions)
```bash
python render_images.py \
  --renderer lines1 \
  --length 10 \
  --size 600 \
  --outfile outputs/test_length10_%SEQ%.jpg
```

### Scoring System

There is a separate scoring system currently based on keras pre-trained ImageNet Challenge models.

If you have an image, response graphs can be generated showing topN responses. By default a stock set of 6 ImageNet models will be used, and the output file will be graph_foo.

```bash
python score_images.py \
  --input-glob 'tick.jpg' \
  --target-class tick \
  --do-graphfile
```

![tick graph](https://user-images.githubusercontent.com/945979/69919751-35bf0980-14e5-11ea-9e03-7ead3667d3c7.jpg)

Want to see more graphs? Try all keras imagenet models (currently 18):

```bash
python score_images.py \
  --input-glob 'tick.jpg' \
  --target-class tick \
  --networks all \
  --do-graphfile
```

![tick graph with more networks](https://user-images.githubusercontent.com/945979/69919752-35bf0980-14e5-11ea-8ade-8f0f65805da7.jpg)



### Planning System

First version - make a bald eagle.

```bash
mkdir -p outputs/draw_bald_eagle_1060
python plan_image.py \
  --outdir outputs/draw_bald_eagle_1060 \
  --imagenet-index 22 \
  --random-seed 1060 \
  --renderer lines1 \
  --num-lines 30
```

...

(stay tuned)

